<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minesweeper</title>
    <style>
        :root {
            --bg-color: #cccbc8;
            --card-bg: #eae9e6;
            --text-color: #1a1a1a;
            --text-muted: #555555;
            --cell-bg: #bcbbb8;
            --cell-hover: #acaba8;
            --cell-revealed: #dfdedd;
            --cell-border: #a4a3a0;
            --mine-bg: #d4a0a0;
            --btn-bg: #1a1a1a;
            --btn-text: #dcdbd8;
            --btn-hover: #333333;
            --tab-active: #1a1a1a;
            --tab-inactive: #666666;
            --alert-bg: #d4a0a0;
            --alert-text: #8b0000;
            --success-bg: #a0c4a0;
            --success-text: #1a4d1a;
        }

        [data-theme="dark"] {
            --bg-color: #1a202c;
            --card-bg: #2d3748;
            --text-color: #f7fafc;
            --text-muted: #a0aec0;
            --cell-bg: #4a5568;
            --cell-hover: #718096;
            --cell-revealed: #2d3748;
            --cell-border: #4a5568;
            --mine-bg: #742a2a;
            --btn-bg: #f7fafc;
            --btn-text: #1a202c;
            --btn-hover: #e2e8f0;
            --tab-active: #f7fafc;
            --tab-inactive: #718096;
            --alert-bg: #742a2a;
            --alert-text: #fed7d7;
            --success-bg: #276749;
            --success-text: #c6f6d5;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            background-color: var(--bg-color);
            margin: 0;
            padding: 20px;
            transition: background-color 0.3s;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            padding: 24px;
            max-width: 100%;
            transition: background-color 0.3s;
        }

        .header {
            text-align: center;
            margin-bottom: 16px;
        }

        h1 {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-color);
            margin: 0;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--cell-bg);
            padding: 4px 8px;
            border-radius: 6px;
            margin-bottom: 12px;
        }

        .stat-box {
            background: var(--bg-color);
            padding: 4px 12px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            font-weight: 700;
            color: var(--text-color);
            min-width: 60px;
            text-align: center;
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .difficulty-tabs {
            display: flex;
            gap: 4px;
        }

        .tab {
            padding: 8px 12px;
            font-size: 13px;
            font-weight: 500;
            border: none;
            background: none;
            color: var(--tab-inactive);
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .tab:hover {
            color: var(--text-color);
            background: var(--cell-bg);
        }

        .tab.active {
            color: var(--tab-active);
            background: var(--cell-bg);
        }

        .new-game-btn {
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 600;
            background: var(--btn-bg);
            color: var(--btn-text);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .new-game-btn:hover {
            background: var(--btn-hover);
        }

        .face-btn {
            padding: 4px 12px;
            font-size: 24px;
            background: var(--bg-color);
            border: none;
            cursor: pointer;
            border-radius: 6px;
            transition: transform 0.1s, background-color 0.2s;
            line-height: 1;
        }

        .face-btn:hover {
            background: var(--cell-hover);
        }

        .face-btn:active {
            transform: scale(0.95);
        }

        .bottom-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--cell-border);
            flex-wrap: wrap;
        }

        .toggle-buttons {
            display: flex;
            gap: 4px;
        }

        .theme-btn {
            padding: 8px;
            font-size: 16px;
            background: none;
            border: none;
            cursor: pointer;
            border-radius: 6px;
            transition: background-color 0.2s;
        }

        .theme-btn:hover {
            background: var(--cell-bg);
        }

        .alert {
            display: none;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 16px;
        }

        .alert.visible {
            display: flex;
        }

        .alert-error {
            background: var(--alert-bg);
            color: var(--alert-text);
        }

        .alert-success {
            background: var(--success-bg);
            color: var(--success-text);
        }

        .alert-icon {
            width: 18px;
            height: 18px;
            flex-shrink: 0;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .game-board {
            display: grid;
            gap: 2px;
            margin: 16px 0;
        }

        .cell {
            width: 28px;
            height: 28px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 13px;
            font-weight: 600;
            background: var(--cell-bg);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.15s;
            user-select: none;
            position: relative;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .cell:hover:not(.revealed) {
            background: var(--cell-hover);
        }

        .cell.revealed {
            background: var(--cell-revealed);
            cursor: default;
        }

        .cell.mine {
            background: var(--mine-bg);
        }

        .cell.mine-exploded {
            background: var(--mine-bg);
            animation: pulse 0.3s ease-out;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .cell .question-icon {
            color: var(--text-muted);
            font-weight: 700;
        }

        .num1 { color: #3182ce; }
        .num2 { color: #38a169; }
        .num3 { color: #e53e3e; }
        .num4 { color: #805ad5; }
        .num5 { color: #d69e2e; }
        .num6 { color: #319795; }
        .num7 { color: #1a202c; }
        .num8 { color: #718096; }

        [data-theme="dark"] .num1 { color: #63b3ed; }
        [data-theme="dark"] .num2 { color: #68d391; }
        [data-theme="dark"] .num3 { color: #fc8181; }
        [data-theme="dark"] .num4 { color: #b794f4; }
        [data-theme="dark"] .num5 { color: #f6e05e; }
        [data-theme="dark"] .num6 { color: #4fd1c5; }
        [data-theme="dark"] .num7 { color: #f7fafc; }
        [data-theme="dark"] .num8 { color: #a0aec0; }

        .instructions {
            font-size: 12px;
            color: var(--text-muted);
            text-align: left;
            line-height: 1.6;
        }

        .high-scores {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--cell-border);
            width: 100%;
        }

        .high-scores h3 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-color);
            margin: 0 0 8px 0;
        }

        .high-scores-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            font-size: 12px;
        }

        .high-score-item {
            display: flex;
            justify-content: space-between;
            color: var(--text-muted);
        }

        .high-score-item span:last-child {
            font-weight: 600;
            color: var(--text-color);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.visible {
            display: flex;
        }

        .modal-content {
            background: var(--card-bg);
            padding: 24px;
            border-radius: 12px;
            min-width: 280px;
        }

        .modal-content h2 {
            font-size: 18px;
            margin: 0 0 16px 0;
            color: var(--text-color);
        }

        .modal-content label {
            display: block;
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .modal-content input {
            width: 100%;
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid var(--cell-border);
            border-radius: 6px;
            margin-bottom: 12px;
            background: var(--bg-color);
            color: var(--text-color);
        }

        .modal-buttons {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 8px;
        }

        .modal-buttons button {
            padding: 8px 16px;
            font-size: 13px;
            border-radius: 6px;
            cursor: pointer;
            border: none;
        }

        .modal-buttons .cancel-btn {
            background: var(--cell-bg);
            color: var(--text-color);
        }

        .modal-buttons .start-btn {
            background: var(--btn-bg);
            color: var(--btn-text);
        }

        .keyboard-hints {
            margin-top: 12px;
            font-size: 11px;
            color: var(--text-muted);
        }

        .keyboard-hints kbd {
            background: var(--cell-bg);
            padding: 2px 5px;
            border-radius: 3px;
            font-family: inherit;
            font-size: 10px;
        }

        /* Animations */
        @keyframes mine-reveal {
            0% { transform: scale(0); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .mine-reveal {
            animation: mine-reveal 0.15s ease-out forwards;
        }

        .confetti {
            position: fixed;
            width: 8px;
            height: 8px;
            z-index: 1000;
            animation: confetti-fall 3s linear forwards;
        }

        @keyframes confetti-fall {
            0% { transform: translateY(-10vh) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }

        @media (max-width: 500px) {
            .card { padding: 16px; }

            .difficulty-tabs {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 4px;
            }

            .tab {
                padding: 6px 8px;
                font-size: 11px;
            }

            .bottom-controls {
                flex-direction: column;
                gap: 8px;
            }

            .high-scores {
                margin-top: 12px;
                padding-top: 12px;
            }

            .high-scores-grid {
                grid-template-columns: 1fr 1fr;
                gap: 4px;
                font-size: 11px;
            }

            .high-score-item {
                padding: 4px 8px;
                background: var(--cell-bg);
                border-radius: 4px;
            }

            .keyboard-hints { display: none; }

            .cell { width: 24px; height: 24px; font-size: 11px; border-radius: 2px; }
        }

        @media (max-width: 360px) {
            .card { padding: 12px; }
            .cell { width: 20px; height: 20px; font-size: 10px; border-radius: 1px; }
            .tab { padding: 5px 6px; font-size: 10px; }
            .stat-box { padding: 3px 8px; font-size: 14px; min-width: 50px; }
            .face-btn { font-size: 20px; padding: 3px 8px; }
        }
    </style>
</head>
<body>
    <div class="card">
        <div class="game-header">
            <div class="stat-box"><span id="flag-count">0</span></div>
            <button class="face-btn" id="face-btn" title="New Game">ðŸ˜Š</button>
            <div class="stat-box"><span id="timer">00:00</span></div>
        </div>

        <div class="alert alert-error" id="alert-error">
            <svg class="alert-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <circle cx="12" cy="12" r="10" stroke-width="2"/>
                <path stroke-width="2" d="M12 8v4m0 4h.01"/>
            </svg>
            <span>Game Over!</span>
        </div>

        <div class="alert alert-success" id="alert-success">
            <svg class="alert-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <circle cx="12" cy="12" r="10" stroke-width="2"/>
                <path stroke-width="2" d="M9 12l2 2 4-4"/>
            </svg>
            <span id="success-message">You Win!</span>
        </div>

        <div class="game-container">
            <div class="game-board" id="game-board"></div>
        </div>

        <div class="instructions">
            Tap to reveal â€¢ Long press to flag
        </div>

        <div class="bottom-controls">
            <div class="difficulty-tabs">
                <button class="tab active" data-difficulty="easy">Beginner</button>
                <button class="tab" data-difficulty="medium">Intermediate</button>
                <button class="tab" data-difficulty="hard">Expert</button>
                <button class="tab" data-difficulty="expert">Nightmare</button>
                <button class="tab" data-difficulty="custom">Custom</button>
            </div>
            <div class="toggle-buttons">
                <button class="theme-btn" id="sound-toggle" title="Toggle sound">ðŸ”‡</button>
                <button class="theme-btn" id="theme-toggle" title="Toggle theme">ðŸŒ™</button>
            </div>
        </div>

        <div class="high-scores">
            <h3>Best Times</h3>
            <div class="high-scores-grid">
                <div class="high-score-item"><span>Beginner</span><span id="best-easy">--:--</span></div>
                <div class="high-score-item"><span>Intermediate</span><span id="best-medium">--:--</span></div>
                <div class="high-score-item"><span>Expert</span><span id="best-hard">--:--</span></div>
                <div class="high-score-item"><span>Nightmare</span><span id="best-expert">--:--</span></div>
            </div>
        </div>

        <div class="keyboard-hints">
            <kbd>R</kbd> New game &nbsp; <kbd>D</kbd> Theme &nbsp; <kbd>1</kbd>-<kbd>4</kbd> Difficulty
        </div>
    </div>

    <!-- Custom difficulty modal -->
    <div class="modal" id="custom-modal">
        <div class="modal-content">
            <h2>Custom Game</h2>
            <label for="custom-rows">Rows (5-30)</label>
            <input type="number" id="custom-rows" min="5" max="30" value="10">
            <label for="custom-cols">Columns (5-50)</label>
            <input type="number" id="custom-cols" min="5" max="50" value="10">
            <label for="custom-mines">Mines</label>
            <input type="number" id="custom-mines" min="1" value="15">
            <div class="modal-buttons">
                <button class="cancel-btn" id="custom-cancel">Cancel</button>
                <button class="start-btn" id="custom-start">Start</button>
            </div>
        </div>
    </div>

    <script>
        class Minesweeper {
            constructor() {
                this.difficulties = {
                    easy: { rows: 9, cols: 9, mines: 10 },
                    medium: { rows: 16, cols: 16, mines: 40 },
                    hard: { rows: 16, cols: 30, mines: 99 },
                    expert: { rows: 24, cols: 30, mines: 200 }
                };

                this.currentDifficulty = 'easy';
                this.rows = 9;
                this.cols = 9;
                this.mines = 10;
                this.board = [];
                this.revealed = 0;
                this.flagCount = 0;
                this.gameOver = false;
                this.gameStarted = false;
                this.timerInterval = null;
                this.timerValue = 0;
                this.isAnimating = false;
                this.longPressTimer = null;
                this.longPressTriggered = false;

                this.loadHighScores();
                this.loadTheme();
                this.loadSound();
                this.audioContext = null;
                this.setupEventListeners();
                this.faceBtn = document.getElementById('face-btn');

                // Try to load saved game, otherwise init new
                if (!this.loadGameState()) {
                    this.init();
                }
            }

            saveGameState() {
                // Only save if game is in progress
                if (!this.gameStarted || this.gameOver) {
                    localStorage.removeItem('minesweeper-gamestate');
                    return;
                }

                const state = {
                    board: this.board,
                    rows: this.rows,
                    cols: this.cols,
                    mines: this.mines,
                    revealed: this.revealed,
                    flagCount: this.flagCount,
                    timerValue: this.timerValue,
                    currentDifficulty: this.currentDifficulty,
                    cellsToWin: this.cellsToWin
                };
                localStorage.setItem('minesweeper-gamestate', JSON.stringify(state));
            }

            loadGameState() {
                const saved = localStorage.getItem('minesweeper-gamestate');
                if (!saved) return false;

                try {
                    const state = JSON.parse(saved);

                    this.board = state.board;
                    this.rows = state.rows;
                    this.cols = state.cols;
                    this.mines = state.mines;
                    this.revealed = state.revealed;
                    this.flagCount = state.flagCount;
                    this.timerValue = state.timerValue;
                    this.currentDifficulty = state.currentDifficulty;
                    this.cellsToWin = state.cellsToWin;
                    this.gameStarted = true;
                    this.gameOver = false;

                    // Render the restored board
                    this.renderBoard();
                    this.updateTimer();
                    this.updateFlagCount();
                    this.displayHighScores();
                    this.updateTabs();

                    // Restart timer
                    this.timerInterval = setInterval(() => {
                        this.timerValue++;
                        this.updateTimer();
                        this.saveGameState();
                    }, 1000);

                    return true;
                } catch (e) {
                    localStorage.removeItem('minesweeper-gamestate');
                    return false;
                }
            }

            clearGameState() {
                localStorage.removeItem('minesweeper-gamestate');
            }

            loadHighScores() {
                const stored = localStorage.getItem('minesweeper-highscores-v2');
                this.highScores = stored ? JSON.parse(stored) : {
                    easy: null, medium: null, hard: null, expert: null
                };
            }

            saveHighScores() {
                localStorage.setItem('minesweeper-highscores-v2', JSON.stringify(this.highScores));
            }

            displayHighScores() {
                const format = (time) => {
                    if (time === null) return '--:--';
                    const mins = Math.floor(time / 60);
                    const secs = time % 60;
                    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                };
                document.getElementById('best-easy').textContent = format(this.highScores.easy);
                document.getElementById('best-medium').textContent = format(this.highScores.medium);
                document.getElementById('best-hard').textContent = format(this.highScores.hard);
                document.getElementById('best-expert').textContent = format(this.highScores.expert);
            }

            checkHighScore() {
                if (this.currentDifficulty === 'custom') return false;
                const current = this.highScores[this.currentDifficulty];
                if (current === null || this.timerValue < current) {
                    this.highScores[this.currentDifficulty] = this.timerValue;
                    this.saveHighScores();
                    this.displayHighScores();
                    return true;
                }
                return false;
            }

            loadTheme() {
                const urlParams = new URLSearchParams(window.location.search);
                const urlTheme = urlParams.get('theme');
                const savedTheme = localStorage.getItem('minesweeper-theme');
                const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';

                const theme = (urlTheme === 'dark' || urlTheme === 'light')
                    ? urlTheme
                    : (savedTheme || systemTheme);
                document.documentElement.setAttribute('data-theme', theme);
                this.updateThemeButton(theme);
            }

            toggleTheme() {
                const current = document.documentElement.getAttribute('data-theme');
                const newTheme = current === 'dark' ? 'light' : 'dark';
                document.documentElement.setAttribute('data-theme', newTheme);
                localStorage.setItem('minesweeper-theme', newTheme);
                this.updateThemeButton(newTheme);
            }

            updateThemeButton(theme) {
                document.getElementById('theme-toggle').textContent = theme === 'dark' ? 'â˜€ï¸' : 'ðŸŒ™';
            }

            loadSound() {
                this.soundEnabled = localStorage.getItem('minesweeper-sound') === 'true';
                this.updateSoundButton();
            }

            toggleSound() {
                this.soundEnabled = !this.soundEnabled;
                localStorage.setItem('minesweeper-sound', this.soundEnabled);
                this.updateSoundButton();
                if (this.soundEnabled) {
                    this.initAudio();
                    this.playSound('click');
                }
            }

            updateSoundButton() {
                document.getElementById('sound-toggle').textContent = this.soundEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
            }

            async initAudio() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
            }

            async playSound(type) {
                if (!this.soundEnabled) return;

                await this.initAudio();
                if (!this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                const now = this.audioContext.currentTime;

                switch (type) {
                    case 'click':
                        oscillator.frequency.value = 600;
                        oscillator.type = 'sine';
                        gainNode.gain.setValueAtTime(0.15, now);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
                        oscillator.start(now);
                        oscillator.stop(now + 0.08);
                        break;

                    case 'flag':
                        oscillator.frequency.value = 800;
                        oscillator.type = 'triangle';
                        gainNode.gain.setValueAtTime(0.12, now);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                        oscillator.start(now);
                        oscillator.stop(now + 0.1);
                        break;

                    case 'explosion':
                        oscillator.frequency.value = 150;
                        oscillator.type = 'sawtooth';
                        gainNode.gain.setValueAtTime(0.3, now);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                        oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.4);
                        oscillator.start(now);
                        oscillator.stop(now + 0.4);
                        break;

                    case 'win':
                        // Play a short victory melody
                        const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
                        notes.forEach((freq, i) => {
                            const osc = this.audioContext.createOscillator();
                            const gain = this.audioContext.createGain();
                            osc.connect(gain);
                            gain.connect(this.audioContext.destination);
                            osc.frequency.value = freq;
                            osc.type = 'sine';
                            const startTime = now + i * 0.12;
                            gain.gain.setValueAtTime(0.2, startTime);
                            gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.2);
                            osc.start(startTime);
                            osc.stop(startTime + 0.2);
                        });
                        return; // Don't start the main oscillator

                    case 'reveal':
                        oscillator.frequency.value = 400 + Math.random() * 100;
                        oscillator.type = 'sine';
                        gainNode.gain.setValueAtTime(0.08, now);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                        oscillator.start(now);
                        oscillator.stop(now + 0.05);
                        break;
                }
            }

            init() {
                if (this.isAnimating) return;

                // Clear saved game state
                this.clearGameState();

                this.board = [];
                this.revealed = 0;
                this.flagCount = 0;
                this.gameOver = false;
                this.gameStarted = false;
                this.cellsToWin = (this.rows * this.cols) - this.mines;
                clearInterval(this.timerInterval);
                this.timerValue = 0;
                this.updateTimer();
                this.updateFlagCount();

                // Reset face
                document.getElementById('face-btn').textContent = 'ðŸ˜Š';

                // Hide alerts
                document.getElementById('alert-error').classList.remove('visible');
                document.getElementById('alert-success').classList.remove('visible');

                // Create board
                for (let i = 0; i < this.rows; i++) {
                    const row = [];
                    for (let j = 0; j < this.cols; j++) {
                        row.push({
                            isMine: false,
                            isRevealed: false,
                            isFlagged: false,
                            isQuestion: false,
                            neighborMines: 0
                        });
                    }
                    this.board.push(row);
                }

                this.renderBoard();
                this.displayHighScores();
                this.updateTabs();
            }

            updateTabs() {
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.difficulty === this.currentDifficulty);
                });
            }

            startGame(firstRow, firstCol) {
                this.placeMines(firstRow, firstCol);
                this.calculateNeighborMines();
                this.gameStarted = true;
                this.timerInterval = setInterval(() => {
                    this.timerValue++;
                    this.updateTimer();
                    this.saveGameState();
                }, 1000);
                this.saveGameState();
            }

            placeMines(safeRow, safeCol) {
                const positions = [];
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        if (Math.abs(i - safeRow) <= 1 && Math.abs(j - safeCol) <= 1) continue;
                        positions.push({ row: i, col: j });
                    }
                }

                for (let i = positions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [positions[i], positions[j]] = [positions[j], positions[i]];
                }

                const mineCount = Math.min(this.mines, positions.length);
                for (let i = 0; i < mineCount; i++) {
                    const { row, col } = positions[i];
                    this.board[row][col].isMine = true;
                }
            }

            calculateNeighborMines() {
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        if (this.board[i][j].isMine) continue;
                        let count = 0;
                        for (let di = -1; di <= 1; di++) {
                            for (let dj = -1; dj <= 1; dj++) {
                                if (di === 0 && dj === 0) continue;
                                const ni = i + di, nj = j + dj;
                                if (ni >= 0 && ni < this.rows && nj >= 0 && nj < this.cols) {
                                    if (this.board[ni][nj].isMine) count++;
                                }
                            }
                        }
                        this.board[i][j].neighborMines = count;
                    }
                }
            }

            renderBoard() {
                const gameBoard = document.getElementById('game-board');
                gameBoard.innerHTML = '';
                const cellSize = window.innerWidth <= 360 ? 20 : window.innerWidth <= 500 ? 24 : 28;
                gameBoard.style.gridTemplateRows = `repeat(${this.rows}, ${cellSize}px)`;
                gameBoard.style.gridTemplateColumns = `repeat(${this.cols}, ${cellSize}px)`;

                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = i;
                        cell.dataset.col = j;
                        this.updateCellDisplay(cell, this.board[i][j]);
                        gameBoard.appendChild(cell);
                    }
                }
            }

            updateCellDisplay(cellElement, cellData) {
                cellElement.innerHTML = '';
                cellElement.className = 'cell';

                if (cellData.isRevealed) {
                    cellElement.classList.add('revealed');
                    if (cellData.isMine) {
                        cellElement.classList.add('mine');
                        cellElement.textContent = 'ðŸ’£';
                    } else if (cellData.neighborMines > 0) {
                        cellElement.classList.add(`num${cellData.neighborMines}`);
                        cellElement.textContent = cellData.neighborMines;
                    }
                } else if (cellData.isFlagged) {
                    cellElement.textContent = 'ðŸš©';
                } else if (cellData.isQuestion) {
                    cellElement.innerHTML = '<span class="question-icon">?</span>';
                }
            }

            setupEventListeners() {
                const gameBoard = document.getElementById('game-board');
                const faceBtn = document.getElementById('face-btn');

                // Theme toggle
                document.getElementById('theme-toggle').addEventListener('click', () => this.toggleTheme());

                // Sound toggle
                document.getElementById('sound-toggle').addEventListener('click', () => this.toggleSound());

                // Face button (new game)
                faceBtn.addEventListener('click', () => this.init());

                // Mouse down on board - worried face
                gameBoard.addEventListener('mousedown', (e) => {
                    if (this.gameOver || e.button !== 0) return;
                    faceBtn.textContent = 'ðŸ˜®';
                });

                // Mouse up - restore face
                window.addEventListener('mouseup', () => {
                    if (!this.gameOver) {
                        faceBtn.textContent = 'ðŸ˜Š';
                    }
                });

                // Difficulty tabs
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        if (this.isAnimating) return;
                        if (this.gameStarted && !this.gameOver) return;

                        const diff = tab.dataset.difficulty;
                        if (diff === 'custom') {
                            document.getElementById('custom-modal').classList.add('visible');
                            return;
                        }

                        this.setDifficulty(diff);
                    });
                });

                // Left click
                gameBoard.addEventListener('click', (e) => {
                    if (this.gameOver || this.longPressTriggered) {
                        this.longPressTriggered = false;
                        return;
                    }

                    const cell = e.target.closest('.cell');
                    if (!cell) return;

                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    const cellData = this.board[row][col];

                    if (cellData.isFlagged || cellData.isQuestion) return;

                    if (!this.gameStarted) this.startGame(row, col);
                    this.playSound('click');
                    this.revealCell(row, col);
                    this.saveGameState();
                });

                // Right click (skip if touch long-press is handling it)
                gameBoard.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    if (this.gameOver) return;
                    if (this.longPressTimer) return; // Touch is handling this

                    const cell = e.target.closest('.cell');
                    if (!cell) return;

                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);

                    if (this.board[row][col].isRevealed) return;

                    this.playSound('flag');
                    this.cycleFlagState(row, col);
                    this.updateCellDisplay(cell, this.board[row][col]);
                    this.updateFlagCount();
                    this.saveGameState();
                });

                // Double click chord
                gameBoard.addEventListener('dblclick', (e) => {
                    if (this.gameOver) return;
                    const cell = e.target.closest('.cell');
                    if (!cell) return;

                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    const cellData = this.board[row][col];

                    if (cellData.isRevealed && cellData.neighborMines > 0) {
                        this.chordReveal(row, col);
                        this.saveGameState();
                    }
                });

                // Long press for mobile
                gameBoard.addEventListener('touchstart', (e) => {
                    if (this.gameOver) return;

                    // Show worried face
                    faceBtn.textContent = 'ðŸ˜®';

                    const cell = e.target.closest('.cell');
                    if (!cell) return;

                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    if (this.board[row][col].isRevealed) return;

                    this.longPressTimer = setTimeout(() => {
                        this.longPressTriggered = true;
                        this.playSound('flag');
                        this.cycleFlagState(row, col);
                        this.updateCellDisplay(cell, this.board[row][col]);
                        this.updateFlagCount();
                        this.saveGameState();
                        if (navigator.vibrate) navigator.vibrate(50);
                    }, 500);
                }, { passive: true });

                gameBoard.addEventListener('touchend', (e) => {
                    if (this.longPressTimer) {
                        clearTimeout(this.longPressTimer);
                        this.longPressTimer = null;
                    }
                    // Restore face
                    if (!this.gameOver) faceBtn.textContent = 'ðŸ˜Š';

                    // Handle tap directly (don't wait for click event)
                    if (!this.longPressTriggered && !this.gameOver) {
                        const touch = e.changedTouches[0];
                        const cell = document.elementFromPoint(touch.clientX, touch.clientY)?.closest('.cell');
                        if (cell) {
                            const row = parseInt(cell.dataset.row);
                            const col = parseInt(cell.dataset.col);
                            const cellData = this.board[row][col];
                            if (!cellData.isFlagged && !cellData.isQuestion && !cellData.isRevealed) {
                                if (!this.gameStarted) this.startGame(row, col);
                                this.playSound('click');
                                this.revealCell(row, col);
                                this.saveGameState();
                                e.preventDefault();
                            }
                        }
                    }
                    this.longPressTriggered = false;
                }, { passive: false });

                gameBoard.addEventListener('touchmove', () => {
                    if (this.longPressTimer) {
                        clearTimeout(this.longPressTimer);
                        this.longPressTimer = null;
                    }
                }, { passive: true });

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.target.tagName === 'INPUT' || this.isAnimating) return;

                    switch (e.key.toLowerCase()) {
                        case 'r': this.init(); break;
                        case 'd': this.toggleTheme(); break;
                        case '1': if (!this.gameStarted) this.setDifficulty('easy'); break;
                        case '2': if (!this.gameStarted) this.setDifficulty('medium'); break;
                        case '3': if (!this.gameStarted) this.setDifficulty('hard'); break;
                        case '4': if (!this.gameStarted) this.setDifficulty('expert'); break;
                        case 'escape': document.getElementById('custom-modal').classList.remove('visible'); break;
                    }
                });

                // Custom modal
                document.getElementById('custom-cancel').addEventListener('click', () => {
                    document.getElementById('custom-modal').classList.remove('visible');
                });

                document.getElementById('custom-start').addEventListener('click', () => {
                    const rows = Math.min(30, Math.max(5, parseInt(document.getElementById('custom-rows').value) || 10));
                    const cols = Math.min(50, Math.max(5, parseInt(document.getElementById('custom-cols').value) || 10));
                    const maxMines = (rows * cols) - 9;
                    const mines = Math.min(maxMines, Math.max(1, parseInt(document.getElementById('custom-mines').value) || 15));

                    document.getElementById('custom-modal').classList.remove('visible');
                    this.currentDifficulty = 'custom';
                    this.rows = rows;
                    this.cols = cols;
                    this.mines = mines;
                    this.init();
                });

                document.getElementById('custom-modal').addEventListener('click', (e) => {
                    if (e.target.id === 'custom-modal') {
                        document.getElementById('custom-modal').classList.remove('visible');
                    }
                });
            }

            setDifficulty(difficulty) {
                if (this.isAnimating) return;
                if (this.gameStarted && !this.gameOver) return;

                this.currentDifficulty = difficulty;
                const d = this.difficulties[difficulty];
                this.rows = d.rows;
                this.cols = d.cols;
                this.mines = d.mines;
                this.init();
            }

            cycleFlagState(row, col) {
                const cell = this.board[row][col];
                if (!cell.isFlagged && !cell.isQuestion) {
                    cell.isFlagged = true;
                    this.flagCount++;
                } else if (cell.isFlagged) {
                    cell.isFlagged = false;
                    cell.isQuestion = true;
                    this.flagCount--;
                } else {
                    cell.isQuestion = false;
                }
            }

            revealCell(row, col) {
                const cell = this.board[row][col];
                if (cell.isRevealed || cell.isFlagged || cell.isQuestion) return;

                cell.isRevealed = true;
                this.revealed++;

                const cellElement = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                this.updateCellDisplay(cellElement, cell);

                if (cell.isMine) {
                    cellElement.classList.add('mine-exploded');
                    this.endGame(false, row, col);
                    return;
                }

                if (this.revealed === this.cellsToWin) {
                    this.endGame(true);
                    return;
                }

                if (cell.neighborMines === 0) {
                    for (let di = -1; di <= 1; di++) {
                        for (let dj = -1; dj <= 1; dj++) {
                            if (di === 0 && dj === 0) continue;
                            const ni = row + di, nj = col + dj;
                            if (ni >= 0 && ni < this.rows && nj >= 0 && nj < this.cols) {
                                this.revealCell(ni, nj);
                            }
                        }
                    }
                }
            }

            chordReveal(row, col) {
                const cell = this.board[row][col];
                const toReveal = [];

                for (let di = -1; di <= 1; di++) {
                    for (let dj = -1; dj <= 1; dj++) {
                        if (di === 0 && dj === 0) continue;
                        const ni = row + di, nj = col + dj;
                        if (ni >= 0 && ni < this.rows && nj >= 0 && nj < this.cols) {
                            const neighbor = this.board[ni][nj];
                            if (!neighbor.isRevealed && !neighbor.isFlagged && !neighbor.isQuestion) {
                                toReveal.push({ row: ni, col: nj });
                            }
                        }
                    }
                }

                toReveal.forEach(pos => this.revealCell(pos.row, pos.col));
            }

            endGame(isWin, explodedRow, explodedCol) {
                this.gameOver = true;
                clearInterval(this.timerInterval);
                this.clearGameState();

                // Update face
                document.getElementById('face-btn').textContent = isWin ? 'ðŸ˜Ž' : 'ðŸ˜µ';

                if (!isWin) {
                    this.isAnimating = true;
                    this.playSound('explosion');
                    document.getElementById('alert-error').classList.add('visible');

                    // Reveal mines
                    const minePositions = [];
                    for (let i = 0; i < this.rows; i++) {
                        for (let j = 0; j < this.cols; j++) {
                            if (this.board[i][j].isMine && !(i === explodedRow && j === explodedCol)) {
                                const dist = Math.abs(i - explodedRow) + Math.abs(j - explodedCol);
                                minePositions.push({ row: i, col: j, dist });
                            }
                        }
                    }
                    minePositions.sort((a, b) => a.dist - b.dist);

                    minePositions.forEach((pos, index) => {
                        setTimeout(() => {
                            this.board[pos.row][pos.col].isRevealed = true;
                            const cellElement = document.querySelector(`.cell[data-row="${pos.row}"][data-col="${pos.col}"]`);
                            this.updateCellDisplay(cellElement, this.board[pos.row][pos.col]);
                            cellElement.classList.add('mine-reveal');
                        }, index * 3);
                    });

                    setTimeout(() => { this.isAnimating = false; }, minePositions.length * 3 + 200);
                } else {
                    this.isAnimating = true;
                    this.playSound('win');
                    const isNewRecord = this.checkHighScore();

                    document.getElementById('success-message').textContent = isNewRecord ? 'New Record!' : 'You Win!';
                    document.getElementById('alert-success').classList.add('visible');

                    // Flag remaining mines
                    for (let i = 0; i < this.rows; i++) {
                        for (let j = 0; j < this.cols; j++) {
                            if (this.board[i][j].isMine && !this.board[i][j].isFlagged) {
                                this.board[i][j].isFlagged = true;
                                this.flagCount++;
                                const cellElement = document.querySelector(`.cell[data-row="${i}"][data-col="${j}"]`);
                                this.updateCellDisplay(cellElement, this.board[i][j]);
                            }
                        }
                    }
                    this.updateFlagCount();

                    // Confetti
                    this.playConfetti();
                    setTimeout(() => { this.isAnimating = false; }, 5000);
                }
            }

            playConfetti() {
                const colors = ['#e53e3e', '#38a169', '#3182ce', '#d69e2e', '#805ad5', '#ed64a6'];
                for (let i = 0; i < 100; i++) {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + 'vw';
                    confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDelay = Math.random() * 2 + 's';
                    document.body.appendChild(confetti);
                    setTimeout(() => confetti.remove(), 5500);
                }
            }

            updateFlagCount() {
                document.getElementById('flag-count').textContent = this.mines - this.flagCount;
            }

            updateTimer() {
                const mins = Math.floor(this.timerValue / 60);
                const secs = this.timerValue % 60;
                document.getElementById('timer').textContent =
                    `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
        }

        const game = new Minesweeper();
        window.addEventListener('resize', () => {
            const gameBoard = document.getElementById('game-board');
            const cellSize = window.innerWidth <= 360 ? 20 : window.innerWidth <= 500 ? 24 : 28;
            gameBoard.style.gridTemplateRows = `repeat(${game.rows}, ${cellSize}px)`;
            gameBoard.style.gridTemplateColumns = `repeat(${game.cols}, ${cellSize}px)`;
        });
    </script>
</body>
</html>
